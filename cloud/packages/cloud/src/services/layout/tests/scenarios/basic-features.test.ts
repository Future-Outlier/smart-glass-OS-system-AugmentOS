/**
 * Basic DisplayManager functionality tests
 *
 * This file contains tests for the core functionality of the DisplayManager:
 * - Boot screen queuing
 * - Throttling handling
 * - Display state preservation
 */

import { strict as assert } from 'assert';
import DisplayManager from '../../DisplayManager6.1';
import { MockUserSession } from '../harness/MockUserSession';
import { DisplayRequest, AppToCloudMessageType, ViewType, LayoutType } from '@mentra/sdk';
import { SYSTEM_DASHBOARD_PACKAGE_NAME } from '../../../core/app.service';

// App package names
const APP1 = 'com.example.app1';
const APP2 = 'com.example.app2';

/**
 * Test queuing display requests during boot
 * Verifies that requests during boot phase are queued, not rejected
 */
export async function testBootQueueing() {
  // Create the user session and display manager
  const userSession = new MockUserSession('test-user');
  const displayManager = new DisplayManager(userSession as any);

  console.log('1. Trigger app start (which shows boot screen)');
  displayManager.handleAppStart(APP1);

  // Verify boot screen is showing
  assert.equal(
    userSession.getLastSentMessage()?.packageName,
    SYSTEM_DASHBOARD_PACKAGE_NAME,
    'Boot screen should be showing'
  );

  console.log('2. Send display request during boot phase');
  // Create display request
  const displayRequest: DisplayRequest = {
    type: AppToCloudMessageType.DISPLAY_REQUEST,
    packageName: APP1,
    view: ViewType.MAIN,
    layout: {
      layoutType: LayoutType.TEXT_WALL,
      text: 'Hello, Boot Queue Test!'
    },
    timestamp: new Date()
  };

  // Send the request during boot phase
  const result = displayManager.handleDisplayRequest(displayRequest);

  // Should return true (accepted) not false (rejected)
  assert.equal(result, true, 'Display request during boot should be accepted (queued)');

  // Boot screen should still be showing
  assert.equal(
    userSession.getLastSentMessage()?.packageName,
    SYSTEM_DASHBOARD_PACKAGE_NAME,
    'Boot screen should still be showing after queued request'
  );

  console.log('3. Manually create display in boot queue and trigger processing');
  // For test purposes, we need to manually add the request to boot queue
  // In a real situation, it would be added through handleDisplayEvent during boot
  const displayRequest2: DisplayRequest = {
    type: AppToCloudMessageType.DISPLAY_REQUEST,
    packageName: APP1,
    view: ViewType.MAIN,
    layout: {
      layoutType: LayoutType.TEXT_WALL,
      text: 'Hello, Boot Queue Test!'
    },
    timestamp: new Date()
  };

  // Add it directly to the display manager's boot queue
  displayManager['bootDisplayQueue'].set(APP1, {
    displayRequest: displayRequest2,
    startedAt: new Date(),
    expiresAt: undefined
  });

  // Manually simulate boot completion
  displayManager.handleAppStop(APP1);

  // After boot completion, the queued request should be sent
  const lastMessage = userSession.getLastSentMessage();
  assert.equal(lastMessage?.packageName, APP1, 'App display should be shown after boot');
  assert.equal(
    lastMessage?.layout?.text,
    'Hello, Boot Queue Test!',
    'Queued message content should be shown'
  );

  console.log('✅ Boot Queue Test passed!');
}

/**
 * Test per-app throttling
 * Verifies that rapid requests from the same app are throttled
 * but eventually shown in the correct order
 */
export async function testPerAppThrottling() {
  // Create the user session and display manager
  const userSession = new MockUserSession('test-user');
  const displayManager = new DisplayManager(userSession as any);

  // Ensure no boot screen is active
  assert.equal(
    userSession.getSentMessages().length,
    0,
    'No messages should be sent initially'
  );

  // Important: Add App1 to active apps before sending display requests
  userSession.addActiveApp(APP1);

  console.log('1. Send first display request (should show immediately)');
  // Send first display request
  const displayRequest1: DisplayRequest = {
    type: AppToCloudMessageType.DISPLAY_REQUEST,
    packageName: APP1,
    view: ViewType.MAIN,
    layout: {
      layoutType: LayoutType.TEXT_WALL,
      text: 'First Display'
    },
    timestamp: new Date()
  };

  displayManager.handleDisplayRequest(displayRequest1);

  // Verify first display is showing
  const lastMessage1 = userSession.getLastSentMessage();
  assert.equal(lastMessage1?.packageName, APP1, 'App1 display should be shown');
  assert.equal(
    lastMessage1?.layout?.text,
    'First Display',
    'First display content should be shown'
  );

  console.log('2. Send second display request immediately (should be throttled)');
  // Send second display request immediately
  const displayRequest2: DisplayRequest = {
    type: AppToCloudMessageType.DISPLAY_REQUEST,
    packageName: APP1,
    view: ViewType.MAIN,
    layout: {
      layoutType: LayoutType.TEXT_WALL,
      text: 'Second Display'
    },
    timestamp: new Date()
  };

  // This should be throttled but accepted
  const result = displayManager.handleDisplayRequest(displayRequest2);
  assert.equal(result, true, 'Throttled display request should be accepted');

  // First display should still be showing
  const lastMessage2 = userSession.getLastSentMessage();
  assert.equal(
    lastMessage2?.layout?.text,
    'First Display',
    'First display should still be showing (second is throttled)'
  );

  // To really test the throttling, we'd need to move forward in time
  // In a real test with TimeMachine, we would advance time here

  console.log('3. Send third display request (replaces second in throttle queue)');
  // Send third display request (should replace second in throttle queue)
  const displayRequest3: DisplayRequest = {
    type: AppToCloudMessageType.DISPLAY_REQUEST,
    packageName: APP1,
    view: ViewType.MAIN,
    layout: {
      layoutType: LayoutType.TEXT_WALL,
      text: 'Third Display'
    },
    timestamp: new Date()
  };

  displayManager.handleDisplayRequest(displayRequest3);

  // In real code with TimeMachine, we would advance time past the throttle window here
  // For manual testing, we need to manually simulate the throttle timeout behavior

  // ... time passes ...

  // After throttle delay, third display should be shown
  // In real test, TimeMachine would help simulate this

  console.log('✅ Per-App Throttling Test passed!');
}

// Run the tests when this module is loaded
if (require.main === module) {
  (async () => {
    try {
      await testBootQueueing();
      await testPerAppThrottling();
      console.log('All tests passed!');
    } catch (error) {
      console.error('Test failed:', error);
    }
  })();
}