// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: mcu_client/mentraos_ble.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
private struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
    struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
    typealias Version = _2
}

/// All messages from phone to glasses
struct Mentraos_Ble_PhoneToGlasses: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Optional message ID for request/response correlation
    var msgID: String = .init()

    var payload: Mentraos_Ble_PhoneToGlasses.OneOf_Payload?

    /// Connection Management
    var disconnect: Mentraos_Ble_DisconnectRequest {
        get {
            if case let .disconnect(v)? = payload { return v }
            return Mentraos_Ble_DisconnectRequest()
        }
        set { payload = .disconnect(newValue) }
    }

    var batteryState: Mentraos_Ble_BatteryStateRequest {
        get {
            if case let .batteryState(v)? = payload { return v }
            return Mentraos_Ble_BatteryStateRequest()
        }
        set { payload = .batteryState(newValue) }
    }

    var glassesInfo: Mentraos_Ble_GlassesInfoRequest {
        get {
            if case let .glassesInfo(v)? = payload { return v }
            return Mentraos_Ble_GlassesInfoRequest()
        }
        set { payload = .glassesInfo(newValue) }
    }

    var pairingMode: Mentraos_Ble_PairingModeRequest {
        get {
            if case let .pairingMode(v)? = payload { return v }
            return Mentraos_Ble_PairingModeRequest()
        }
        set { payload = .pairingMode(newValue) }
    }

    var headPosition: Mentraos_Ble_HeadPositionRequest {
        get {
            if case let .headPosition(v)? = payload { return v }
            return Mentraos_Ble_HeadPositionRequest()
        }
        set { payload = .headPosition(newValue) }
    }

    var headUpAngle: Mentraos_Ble_HeadUpAngleConfig {
        get {
            if case let .headUpAngle(v)? = payload { return v }
            return Mentraos_Ble_HeadUpAngleConfig()
        }
        set { payload = .headUpAngle(newValue) }
    }

    var pong: Mentraos_Ble_PongResponse {
        get {
            if case let .pong(v)? = payload { return v }
            return Mentraos_Ble_PongResponse()
        }
        set { payload = .pong(newValue) }
    }

    /// Audio System
    var micState: Mentraos_Ble_MicStateConfig {
        get {
            if case let .micState(v)? = payload { return v }
            return Mentraos_Ble_MicStateConfig()
        }
        set { payload = .micState(newValue) }
    }

    var vadEnabled: Mentraos_Ble_VadEnabledConfig {
        get {
            if case let .vadEnabled(v)? = payload { return v }
            return Mentraos_Ble_VadEnabledConfig()
        }
        set { payload = .vadEnabled(newValue) }
    }

    var vadConfig: Mentraos_Ble_VadConfig {
        get {
            if case let .vadConfig(v)? = payload { return v }
            return Mentraos_Ble_VadConfig()
        }
        set { payload = .vadConfig(newValue) }
    }

    /// Display System
    var displayText: Mentraos_Ble_DisplayText {
        get {
            if case let .displayText(v)? = payload { return v }
            return Mentraos_Ble_DisplayText()
        }
        set { payload = .displayText(newValue) }
    }

    var displayImage: Mentraos_Ble_DisplayImage {
        get {
            if case let .displayImage(v)? = payload { return v }
            return Mentraos_Ble_DisplayImage()
        }
        set { payload = .displayImage(newValue) }
    }

    var preloadImage: Mentraos_Ble_PreloadImage {
        get {
            if case let .preloadImage(v)? = payload { return v }
            return Mentraos_Ble_PreloadImage()
        }
        set { payload = .preloadImage(newValue) }
    }

    var displayCachedImage: Mentraos_Ble_DisplayCachedImage {
        get {
            if case let .displayCachedImage(v)? = payload { return v }
            return Mentraos_Ble_DisplayCachedImage()
        }
        set { payload = .displayCachedImage(newValue) }
    }

    var clearCachedImage_p: Mentraos_Ble_ClearCachedImage {
        get {
            if case let .clearCachedImage_p(v)? = payload { return v }
            return Mentraos_Ble_ClearCachedImage()
        }
        set { payload = .clearCachedImage_p(newValue) }
    }

    var displayScrollingText: Mentraos_Ble_DisplayScrollingText {
        get {
            if case let .displayScrollingText(v)? = payload { return v }
            return Mentraos_Ble_DisplayScrollingText()
        }
        set { payload = .displayScrollingText(newValue) }
    }

    var displayPower: Mentraos_Ble_DisplayPowerConfig {
        get {
            if case let .displayPower(v)? = payload { return v }
            return Mentraos_Ble_DisplayPowerConfig()
        }
        set { payload = .displayPower(newValue) }
    }

    var brightness: Mentraos_Ble_BrightnessConfig {
        get {
            if case let .brightness(v)? = payload { return v }
            return Mentraos_Ble_BrightnessConfig()
        }
        set { payload = .brightness(newValue) }
    }

    var autoBrightness: Mentraos_Ble_AutoBrightnessConfig {
        get {
            if case let .autoBrightness(v)? = payload { return v }
            return Mentraos_Ble_AutoBrightnessConfig()
        }
        set { payload = .autoBrightness(newValue) }
    }

    var autoBrightnessMult: Mentraos_Ble_AutoBrightnessMultiplier {
        get {
            if case let .autoBrightnessMult(v)? = payload { return v }
            return Mentraos_Ble_AutoBrightnessMultiplier()
        }
        set { payload = .autoBrightnessMult(newValue) }
    }

    var drawLine: Mentraos_Ble_DrawLine {
        get {
            if case let .drawLine(v)? = payload { return v }
            return Mentraos_Ble_DrawLine()
        }
        set { payload = .drawLine(newValue) }
    }

    var drawRect: Mentraos_Ble_DrawRect {
        get {
            if case let .drawRect(v)? = payload { return v }
            return Mentraos_Ble_DrawRect()
        }
        set { payload = .drawRect(newValue) }
    }

    var drawCircle: Mentraos_Ble_DrawCircle {
        get {
            if case let .drawCircle(v)? = payload { return v }
            return Mentraos_Ble_DrawCircle()
        }
        set { payload = .drawCircle(newValue) }
    }

    var commit: Mentraos_Ble_CommitDisplay {
        get {
            if case let .commit(v)? = payload { return v }
            return Mentraos_Ble_CommitDisplay()
        }
        set { payload = .commit(newValue) }
    }

    var displayDistance: Mentraos_Ble_DisplayDistanceConfig {
        get {
            if case let .displayDistance(v)? = payload { return v }
            return Mentraos_Ble_DisplayDistanceConfig()
        }
        set { payload = .displayDistance(newValue) }
    }

    var displayHeight: Mentraos_Ble_DisplayHeightConfig {
        get {
            if case let .displayHeight(v)? = payload { return v }
            return Mentraos_Ble_DisplayHeightConfig()
        }
        set { payload = .displayHeight(newValue) }
    }

    var clearDisplay_p: Mentraos_Ble_ClearDisplay {
        get {
            if case let .clearDisplay_p(v)? = payload { return v }
            return Mentraos_Ble_ClearDisplay()
        }
        set { payload = .clearDisplay_p(newValue) }
    }

    /// User Input
    var imuEnabled: Mentraos_Ble_ImuEnabledConfig {
        get {
            if case let .imuEnabled(v)? = payload { return v }
            return Mentraos_Ble_ImuEnabledConfig()
        }
        set { payload = .imuEnabled(newValue) }
    }

    var imuSingle: Mentraos_Ble_ImuSingleRequest {
        get {
            if case let .imuSingle(v)? = payload { return v }
            return Mentraos_Ble_ImuSingleRequest()
        }
        set { payload = .imuSingle(newValue) }
    }

    var imuStream: Mentraos_Ble_ImuStreamConfig {
        get {
            if case let .imuStream(v)? = payload { return v }
            return Mentraos_Ble_ImuStreamConfig()
        }
        set { payload = .imuStream(newValue) }
    }

    var headGesture: Mentraos_Ble_HeadGestureConfig {
        get {
            if case let .headGesture(v)? = payload { return v }
            return Mentraos_Ble_HeadGestureConfig()
        }
        set { payload = .headGesture(newValue) }
    }

    /// System Control
    var restart: Mentraos_Ble_RestartRequest {
        get {
            if case let .restart(v)? = payload { return v }
            return Mentraos_Ble_RestartRequest()
        }
        set { payload = .restart(newValue) }
    }

    var factoryReset: Mentraos_Ble_FactoryResetRequest {
        get {
            if case let .factoryReset(v)? = payload { return v }
            return Mentraos_Ble_FactoryResetRequest()
        }
        set { payload = .factoryReset(newValue) }
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Payload: Equatable, Sendable {
        /// Connection Management
        case disconnect(Mentraos_Ble_DisconnectRequest)
        case batteryState(Mentraos_Ble_BatteryStateRequest)
        case glassesInfo(Mentraos_Ble_GlassesInfoRequest)
        case pairingMode(Mentraos_Ble_PairingModeRequest)
        case headPosition(Mentraos_Ble_HeadPositionRequest)
        case headUpAngle(Mentraos_Ble_HeadUpAngleConfig)
        case pong(Mentraos_Ble_PongResponse)
        /// Audio System
        case micState(Mentraos_Ble_MicStateConfig)
        case vadEnabled(Mentraos_Ble_VadEnabledConfig)
        case vadConfig(Mentraos_Ble_VadConfig)
        /// Display System
        case displayText(Mentraos_Ble_DisplayText)
        case displayImage(Mentraos_Ble_DisplayImage)
        case preloadImage(Mentraos_Ble_PreloadImage)
        case displayCachedImage(Mentraos_Ble_DisplayCachedImage)
        case clearCachedImage_p(Mentraos_Ble_ClearCachedImage)
        case displayScrollingText(Mentraos_Ble_DisplayScrollingText)
        case displayPower(Mentraos_Ble_DisplayPowerConfig)
        case brightness(Mentraos_Ble_BrightnessConfig)
        case autoBrightness(Mentraos_Ble_AutoBrightnessConfig)
        case autoBrightnessMult(Mentraos_Ble_AutoBrightnessMultiplier)
        case drawLine(Mentraos_Ble_DrawLine)
        case drawRect(Mentraos_Ble_DrawRect)
        case drawCircle(Mentraos_Ble_DrawCircle)
        case commit(Mentraos_Ble_CommitDisplay)
        case displayDistance(Mentraos_Ble_DisplayDistanceConfig)
        case displayHeight(Mentraos_Ble_DisplayHeightConfig)
        case clearDisplay_p(Mentraos_Ble_ClearDisplay)
        /// User Input
        case imuEnabled(Mentraos_Ble_ImuEnabledConfig)
        case imuSingle(Mentraos_Ble_ImuSingleRequest)
        case imuStream(Mentraos_Ble_ImuStreamConfig)
        case headGesture(Mentraos_Ble_HeadGestureConfig)
        /// System Control
        case restart(Mentraos_Ble_RestartRequest)
        case factoryReset(Mentraos_Ble_FactoryResetRequest)
    }

    init() {}
}

/// All messages from glasses to phone
struct Mentraos_Ble_GlassesToPhone: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var payload: Mentraos_Ble_GlassesToPhone.OneOf_Payload?

    /// Connection Management
    var batteryStatus: Mentraos_Ble_BatteryStatus {
        get {
            if case let .batteryStatus(v)? = payload { return v }
            return Mentraos_Ble_BatteryStatus()
        }
        set { payload = .batteryStatus(newValue) }
    }

    var chargingState: Mentraos_Ble_ChargingState {
        get {
            if case let .chargingState(v)? = payload { return v }
            return Mentraos_Ble_ChargingState()
        }
        set { payload = .chargingState(newValue) }
    }

    var deviceInfo: Mentraos_Ble_DeviceInfo {
        get {
            if case let .deviceInfo(v)? = payload { return v }
            return Mentraos_Ble_DeviceInfo()
        }
        set { payload = .deviceInfo(newValue) }
    }

    var headPosition: Mentraos_Ble_HeadPosition {
        get {
            if case let .headPosition(v)? = payload { return v }
            return Mentraos_Ble_HeadPosition()
        }
        set { payload = .headPosition(newValue) }
    }

    var headUpAngleSet: Mentraos_Ble_HeadUpAngleResponse {
        get {
            if case let .headUpAngleSet(v)? = payload { return v }
            return Mentraos_Ble_HeadUpAngleResponse()
        }
        set { payload = .headUpAngleSet(newValue) }
    }

    var ping: Mentraos_Ble_PingRequest {
        get {
            if case let .ping(v)? = payload { return v }
            return Mentraos_Ble_PingRequest()
        }
        set { payload = .ping(newValue) }
    }

    /// Audio System
    var vadEvent: Mentraos_Ble_VadEvent {
        get {
            if case let .vadEvent(v)? = payload { return v }
            return Mentraos_Ble_VadEvent()
        }
        set { payload = .vadEvent(newValue) }
    }

    /// Display System
    var imageTransferComplete: Mentraos_Ble_ImageTransferComplete {
        get {
            if case let .imageTransferComplete(v)? = payload { return v }
            return Mentraos_Ble_ImageTransferComplete()
        }
        set { payload = .imageTransferComplete(newValue) }
    }

    /// User Input
    var imuData: Mentraos_Ble_ImuData {
        get {
            if case let .imuData(v)? = payload { return v }
            return Mentraos_Ble_ImuData()
        }
        set { payload = .imuData(newValue) }
    }

    var buttonEvent: Mentraos_Ble_ButtonEvent {
        get {
            if case let .buttonEvent(v)? = payload { return v }
            return Mentraos_Ble_ButtonEvent()
        }
        set { payload = .buttonEvent(newValue) }
    }

    var headGesture: Mentraos_Ble_HeadGesture {
        get {
            if case let .headGesture(v)? = payload { return v }
            return Mentraos_Ble_HeadGesture()
        }
        set { payload = .headGesture(newValue) }
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Payload: Equatable, Sendable {
        /// Connection Management
        case batteryStatus(Mentraos_Ble_BatteryStatus)
        case chargingState(Mentraos_Ble_ChargingState)
        case deviceInfo(Mentraos_Ble_DeviceInfo)
        case headPosition(Mentraos_Ble_HeadPosition)
        case headUpAngleSet(Mentraos_Ble_HeadUpAngleResponse)
        case ping(Mentraos_Ble_PingRequest)
        /// Audio System
        case vadEvent(Mentraos_Ble_VadEvent)
        /// Display System
        case imageTransferComplete(Mentraos_Ble_ImageTransferComplete)
        /// User Input
        case imuData(Mentraos_Ble_ImuData)
        case buttonEvent(Mentraos_Ble_ButtonEvent)
        case headGesture(Mentraos_Ble_HeadGesture)
    }

    init() {}
}

struct Mentraos_Ble_DisconnectRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Mentraos_Ble_BatteryStateRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Mentraos_Ble_BatteryStatus: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// 0-100 percentage
    var level: UInt32 = 0

    var charging: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Mentraos_Ble_ChargingState: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var state: Mentraos_Ble_ChargingState.State = .notCharging

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum State: SwiftProtobuf.Enum, Swift.CaseIterable {
        typealias RawValue = Int
        case notCharging // = 0
        case charging // = 1
        case UNRECOGNIZED(Int)

        init() {
            self = .notCharging
        }

        init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .notCharging
            case 1: self = .charging
            default: self = .UNRECOGNIZED(rawValue)
            }
        }

        var rawValue: Int {
            switch self {
            case .notCharging: return 0
            case .charging: return 1
            case let .UNRECOGNIZED(i): return i
            }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [Mentraos_Ble_ChargingState.State] = [
            .notCharging,
            .charging,
        ]
    }

    init() {}
}

struct Mentraos_Ble_GlassesInfoRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Mentraos_Ble_DeviceInfo: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var fwVersion: String = .init()

    var hwModel: String = .init()

    var features: Mentraos_Ble_DeviceFeatures {
        get { return _features ?? Mentraos_Ble_DeviceFeatures() }
        set { _features = newValue }
    }

    /// Returns true if `features` has been explicitly set.
    var hasFeatures: Bool { return _features != nil }
    /// Clears the value of `features`. Subsequent reads from it will return its default value.
    mutating func clearFeatures() { _features = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _features: Mentraos_Ble_DeviceFeatures?
}

struct Mentraos_Ble_DeviceFeatures: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var camera: Bool = false

    var display: Bool = false

    var audioTx: Bool = false

    var audioRx: Bool = false

    var imu: Bool = false

    var vad: Bool = false

    var micSwitching: Bool = false

    /// Max chunks that can be buffered
    var imageChunkBuffer: UInt32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Mentraos_Ble_PairingModeRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Mentraos_Ble_HeadPositionRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Mentraos_Ble_HeadPosition: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// degrees
    var angle: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Mentraos_Ble_HeadUpAngleConfig: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// degrees
    var angle: UInt32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Mentraos_Ble_HeadUpAngleResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var success: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Mentraos_Ble_PingRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Mentraos_Ble_PongResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Mentraos_Ble_MicStateConfig: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var enabled: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Mentraos_Ble_VadEnabledConfig: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var enabled: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Mentraos_Ble_VadConfig: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// 0-100
    var sensitivity: UInt32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Mentraos_Ble_VadEvent: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var state: Mentraos_Ble_VadEvent.State = .inactive

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum State: SwiftProtobuf.Enum, Swift.CaseIterable {
        typealias RawValue = Int
        case inactive // = 0
        case active // = 1
        case UNRECOGNIZED(Int)

        init() {
            self = .inactive
        }

        init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .inactive
            case 1: self = .active
            default: self = .UNRECOGNIZED(rawValue)
            }
        }

        var rawValue: Int {
            switch self {
            case .inactive: return 0
            case .active: return 1
            case let .UNRECOGNIZED(i): return i
            }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [Mentraos_Ble_VadEvent.State] = [
            .inactive,
            .active,
        ]
    }

    init() {}
}

struct Mentraos_Ble_DisplayText: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var text: String = .init()

    /// RGB565 format (e.g., 0xF800 for red)
    var color: UInt32 = 0

    /// Font identifier
    var fontCode: UInt32 = 0

    var x: UInt32 = 0

    var y: UInt32 = 0

    /// Font size multiplier
    var size: UInt32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

/// Initiates bitmap transfer - actual data comes via binary protocol
struct Mentraos_Ble_DisplayImage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// 2-byte hex string like "002A"
    var streamID: String = .init()

    var x: UInt32 = 0

    var y: UInt32 = 0

    var width: UInt32 = 0

    var height: UInt32 = 0

    /// "rle", "webp", etc.
    var encoding: String = .init()

    var totalChunks: UInt32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Mentraos_Ble_PreloadImage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var streamID: String = .init()

    /// ID for later reference
    var imageID: UInt32 = 0

    var width: UInt32 = 0

    var height: UInt32 = 0

    var encoding: String = .init()

    var totalChunks: UInt32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Mentraos_Ble_DisplayCachedImage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var imageID: UInt32 = 0

    var x: UInt32 = 0

    var y: UInt32 = 0

    var width: UInt32 = 0

    var height: UInt32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Mentraos_Ble_ClearCachedImage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var imageID: UInt32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Mentraos_Ble_DisplayScrollingText: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var text: String = .init()

    var color: UInt32 = 0

    var fontCode: UInt32 = 0

    var x: UInt32 = 0

    var y: UInt32 = 0

    var width: UInt32 = 0

    var height: UInt32 = 0

    var align: Mentraos_Ble_DisplayScrollingText.Alignment = .left

    /// pixels between lines
    var lineSpacing: UInt32 = 0

    /// pixels/sec scrolling up
    var speed: UInt32 = 0

    /// font size multiplier
    var size: UInt32 = 0

    /// wrap to top when finished
    var loop: Bool = false

    /// delay before restart (if looping)
    var pauseMs: UInt32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum Alignment: SwiftProtobuf.Enum, Swift.CaseIterable {
        typealias RawValue = Int
        case left // = 0
        case center // = 1
        case right // = 2
        case UNRECOGNIZED(Int)

        init() {
            self = .left
        }

        init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .left
            case 1: self = .center
            case 2: self = .right
            default: self = .UNRECOGNIZED(rawValue)
            }
        }

        var rawValue: Int {
            switch self {
            case .left: return 0
            case .center: return 1
            case .right: return 2
            case let .UNRECOGNIZED(i): return i
            }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [Mentraos_Ble_DisplayScrollingText.Alignment] = [
            .left,
            .center,
            .right,
        ]
    }

    init() {}
}

struct Mentraos_Ble_DisplayPowerConfig: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// true = turn on, false = turn off
    var on: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Mentraos_Ble_BrightnessConfig: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// 0-100
    var value: UInt32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Mentraos_Ble_AutoBrightnessConfig: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var enabled: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Mentraos_Ble_AutoBrightnessMultiplier: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// e.g., 0.8 = 80%
    var multiplier: Float = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Mentraos_Ble_DrawLine: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var color: UInt32 = 0

    var stroke: UInt32 = 0

    var x1: UInt32 = 0

    var y1: UInt32 = 0

    var x2: UInt32 = 0

    var y2: UInt32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Mentraos_Ble_DrawRect: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var color: UInt32 = 0

    var stroke: UInt32 = 0

    var x: UInt32 = 0

    var y: UInt32 = 0

    var width: UInt32 = 0

    var height: UInt32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Mentraos_Ble_DrawCircle: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var color: UInt32 = 0

    var stroke: UInt32 = 0

    var x: UInt32 = 0

    var y: UInt32 = 0

    var radius: UInt32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Mentraos_Ble_CommitDisplay: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Mentraos_Ble_ClearDisplay: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Mentraos_Ble_DisplayDistanceConfig: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var distanceCm: UInt32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Mentraos_Ble_DisplayHeightConfig: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var height: UInt32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Mentraos_Ble_ImageTransferComplete: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var streamID: String = .init()

    var status: Mentraos_Ble_ImageTransferComplete.Status = .ok

    /// List of missing chunk indices
    var missingChunks: [UInt32] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum Status: SwiftProtobuf.Enum, Swift.CaseIterable {
        typealias RawValue = Int
        case ok // = 0
        case incomplete // = 1
        case UNRECOGNIZED(Int)

        init() {
            self = .ok
        }

        init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .ok
            case 1: self = .incomplete
            default: self = .UNRECOGNIZED(rawValue)
            }
        }

        var rawValue: Int {
            switch self {
            case .ok: return 0
            case .incomplete: return 1
            case let .UNRECOGNIZED(i): return i
            }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [Mentraos_Ble_ImageTransferComplete.Status] = [
            .ok,
            .incomplete,
        ]
    }

    init() {}
}

struct Mentraos_Ble_ImuEnabledConfig: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var enabled: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Mentraos_Ble_ImuSingleRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Mentraos_Ble_ImuStreamConfig: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var enabled: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Mentraos_Ble_ImuData: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var accel: Mentraos_Ble_Vector3 {
        get { return _accel ?? Mentraos_Ble_Vector3() }
        set { _accel = newValue }
    }

    /// Returns true if `accel` has been explicitly set.
    var hasAccel: Bool { return _accel != nil }
    /// Clears the value of `accel`. Subsequent reads from it will return its default value.
    mutating func clearAccel() { _accel = nil }

    var gyro: Mentraos_Ble_Vector3 {
        get { return _gyro ?? Mentraos_Ble_Vector3() }
        set { _gyro = newValue }
    }

    /// Returns true if `gyro` has been explicitly set.
    var hasGyro: Bool { return _gyro != nil }
    /// Clears the value of `gyro`. Subsequent reads from it will return its default value.
    mutating func clearGyro() { _gyro = nil }

    var mag: Mentraos_Ble_Vector3 {
        get { return _mag ?? Mentraos_Ble_Vector3() }
        set { _mag = newValue }
    }

    /// Returns true if `mag` has been explicitly set.
    var hasMag: Bool { return _mag != nil }
    /// Clears the value of `mag`. Subsequent reads from it will return its default value.
    mutating func clearMag() { _mag = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _accel: Mentraos_Ble_Vector3?
    fileprivate var _gyro: Mentraos_Ble_Vector3?
    fileprivate var _mag: Mentraos_Ble_Vector3?
}

struct Mentraos_Ble_Vector3: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var x: Float = 0

    var y: Float = 0

    var z: Float = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Mentraos_Ble_ButtonEvent: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var button: Mentraos_Ble_ButtonEvent.Button = .center

    var state: Mentraos_Ble_ButtonEvent.State = .up

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum Button: SwiftProtobuf.Enum, Swift.CaseIterable {
        typealias RawValue = Int
        case center // = 0
        case left // = 1
        case right // = 2
        case UNRECOGNIZED(Int)

        init() {
            self = .center
        }

        init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .center
            case 1: self = .left
            case 2: self = .right
            default: self = .UNRECOGNIZED(rawValue)
            }
        }

        var rawValue: Int {
            switch self {
            case .center: return 0
            case .left: return 1
            case .right: return 2
            case let .UNRECOGNIZED(i): return i
            }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [Mentraos_Ble_ButtonEvent.Button] = [
            .center,
            .left,
            .right,
        ]
    }

    enum State: SwiftProtobuf.Enum, Swift.CaseIterable {
        typealias RawValue = Int
        case up // = 0
        case down // = 1
        case UNRECOGNIZED(Int)

        init() {
            self = .up
        }

        init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .up
            case 1: self = .down
            default: self = .UNRECOGNIZED(rawValue)
            }
        }

        var rawValue: Int {
            switch self {
            case .up: return 0
            case .down: return 1
            case let .UNRECOGNIZED(i): return i
            }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [Mentraos_Ble_ButtonEvent.State] = [
            .up,
            .down,
        ]
    }

    init() {}
}

struct Mentraos_Ble_HeadGesture: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var gesture: Mentraos_Ble_HeadGesture.Gesture = .nod

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum Gesture: SwiftProtobuf.Enum, Swift.CaseIterable {
        typealias RawValue = Int
        case nod // = 0
        case shake // = 1
        case headUp // = 2
        case UNRECOGNIZED(Int)

        init() {
            self = .nod
        }

        init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .nod
            case 1: self = .shake
            case 2: self = .headUp
            default: self = .UNRECOGNIZED(rawValue)
            }
        }

        var rawValue: Int {
            switch self {
            case .nod: return 0
            case .shake: return 1
            case .headUp: return 2
            case let .UNRECOGNIZED(i): return i
            }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        static let allCases: [Mentraos_Ble_HeadGesture.Gesture] = [
            .nod,
            .shake,
            .headUp,
        ]
    }

    init() {}
}

struct Mentraos_Ble_HeadGestureConfig: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var gesture: Mentraos_Ble_HeadGesture.Gesture = .nod

    var enabled: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Mentraos_Ble_RestartRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Mentraos_Ble_FactoryResetRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

private let _protobuf_package = "mentraos.ble"

extension Mentraos_Ble_PhoneToGlasses: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".PhoneToGlasses"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}msg_id\0\u{2}\u{9}disconnect\0\u{3}battery_state\0\u{3}glasses_info\0\u{3}pairing_mode\0\u{3}head_position\0\u{3}head_up_angle\0\u{1}pong\0\u{4}\u{4}mic_state\0\u{3}vad_enabled\0\u{3}vad_config\0\u{4}\u{8}display_text\0\u{3}display_image\0\u{3}preload_image\0\u{3}display_cached_image\0\u{3}clear_cached_image\0\u{3}display_scrolling_text\0\u{3}display_power\0\u{1}brightness\0\u{3}auto_brightness\0\u{3}auto_brightness_mult\0\u{3}draw_line\0\u{3}draw_rect\0\u{3}draw_circle\0\u{1}commit\0\u{3}display_distance\0\u{3}display_height\0\u{3}clear_display\0\u{4}\u{4}imu_enabled\0\u{3}imu_single\0\u{3}imu_stream\0\u{3}head_gesture\0\u{2}\u{7}restart\0\u{3}factory_reset\0")

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &msgID)
            case 10: try {
                    var v: Mentraos_Ble_DisconnectRequest?
                    var hadOneofValue = false
                    if let current = self.payload {
                        hadOneofValue = true
                        if case let .disconnect(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.payload = .disconnect(v)
                    }
                }()
            case 11: try {
                    var v: Mentraos_Ble_BatteryStateRequest?
                    var hadOneofValue = false
                    if let current = self.payload {
                        hadOneofValue = true
                        if case let .batteryState(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.payload = .batteryState(v)
                    }
                }()
            case 12: try {
                    var v: Mentraos_Ble_GlassesInfoRequest?
                    var hadOneofValue = false
                    if let current = self.payload {
                        hadOneofValue = true
                        if case let .glassesInfo(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.payload = .glassesInfo(v)
                    }
                }()
            case 13: try {
                    var v: Mentraos_Ble_PairingModeRequest?
                    var hadOneofValue = false
                    if let current = self.payload {
                        hadOneofValue = true
                        if case let .pairingMode(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.payload = .pairingMode(v)
                    }
                }()
            case 14: try {
                    var v: Mentraos_Ble_HeadPositionRequest?
                    var hadOneofValue = false
                    if let current = self.payload {
                        hadOneofValue = true
                        if case let .headPosition(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.payload = .headPosition(v)
                    }
                }()
            case 15: try {
                    var v: Mentraos_Ble_HeadUpAngleConfig?
                    var hadOneofValue = false
                    if let current = self.payload {
                        hadOneofValue = true
                        if case let .headUpAngle(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.payload = .headUpAngle(v)
                    }
                }()
            case 16: try {
                    var v: Mentraos_Ble_PongResponse?
                    var hadOneofValue = false
                    if let current = self.payload {
                        hadOneofValue = true
                        if case let .pong(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.payload = .pong(v)
                    }
                }()
            case 20: try {
                    var v: Mentraos_Ble_MicStateConfig?
                    var hadOneofValue = false
                    if let current = self.payload {
                        hadOneofValue = true
                        if case let .micState(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.payload = .micState(v)
                    }
                }()
            case 21: try {
                    var v: Mentraos_Ble_VadEnabledConfig?
                    var hadOneofValue = false
                    if let current = self.payload {
                        hadOneofValue = true
                        if case let .vadEnabled(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.payload = .vadEnabled(v)
                    }
                }()
            case 22: try {
                    var v: Mentraos_Ble_VadConfig?
                    var hadOneofValue = false
                    if let current = self.payload {
                        hadOneofValue = true
                        if case let .vadConfig(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.payload = .vadConfig(v)
                    }
                }()
            case 30: try {
                    var v: Mentraos_Ble_DisplayText?
                    var hadOneofValue = false
                    if let current = self.payload {
                        hadOneofValue = true
                        if case let .displayText(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.payload = .displayText(v)
                    }
                }()
            case 31: try {
                    var v: Mentraos_Ble_DisplayImage?
                    var hadOneofValue = false
                    if let current = self.payload {
                        hadOneofValue = true
                        if case let .displayImage(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.payload = .displayImage(v)
                    }
                }()
            case 32: try {
                    var v: Mentraos_Ble_PreloadImage?
                    var hadOneofValue = false
                    if let current = self.payload {
                        hadOneofValue = true
                        if case let .preloadImage(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.payload = .preloadImage(v)
                    }
                }()
            case 33: try {
                    var v: Mentraos_Ble_DisplayCachedImage?
                    var hadOneofValue = false
                    if let current = self.payload {
                        hadOneofValue = true
                        if case let .displayCachedImage(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.payload = .displayCachedImage(v)
                    }
                }()
            case 34: try {
                    var v: Mentraos_Ble_ClearCachedImage?
                    var hadOneofValue = false
                    if let current = self.payload {
                        hadOneofValue = true
                        if case let .clearCachedImage_p(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.payload = .clearCachedImage_p(v)
                    }
                }()
            case 35: try {
                    var v: Mentraos_Ble_DisplayScrollingText?
                    var hadOneofValue = false
                    if let current = self.payload {
                        hadOneofValue = true
                        if case let .displayScrollingText(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.payload = .displayScrollingText(v)
                    }
                }()
            case 36: try {
                    var v: Mentraos_Ble_DisplayPowerConfig?
                    var hadOneofValue = false
                    if let current = self.payload {
                        hadOneofValue = true
                        if case let .displayPower(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.payload = .displayPower(v)
                    }
                }()
            case 37: try {
                    var v: Mentraos_Ble_BrightnessConfig?
                    var hadOneofValue = false
                    if let current = self.payload {
                        hadOneofValue = true
                        if case let .brightness(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.payload = .brightness(v)
                    }
                }()
            case 38: try {
                    var v: Mentraos_Ble_AutoBrightnessConfig?
                    var hadOneofValue = false
                    if let current = self.payload {
                        hadOneofValue = true
                        if case let .autoBrightness(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.payload = .autoBrightness(v)
                    }
                }()
            case 39: try {
                    var v: Mentraos_Ble_AutoBrightnessMultiplier?
                    var hadOneofValue = false
                    if let current = self.payload {
                        hadOneofValue = true
                        if case let .autoBrightnessMult(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.payload = .autoBrightnessMult(v)
                    }
                }()
            case 40: try {
                    var v: Mentraos_Ble_DrawLine?
                    var hadOneofValue = false
                    if let current = self.payload {
                        hadOneofValue = true
                        if case let .drawLine(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.payload = .drawLine(v)
                    }
                }()
            case 41: try {
                    var v: Mentraos_Ble_DrawRect?
                    var hadOneofValue = false
                    if let current = self.payload {
                        hadOneofValue = true
                        if case let .drawRect(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.payload = .drawRect(v)
                    }
                }()
            case 42: try {
                    var v: Mentraos_Ble_DrawCircle?
                    var hadOneofValue = false
                    if let current = self.payload {
                        hadOneofValue = true
                        if case let .drawCircle(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.payload = .drawCircle(v)
                    }
                }()
            case 43: try {
                    var v: Mentraos_Ble_CommitDisplay?
                    var hadOneofValue = false
                    if let current = self.payload {
                        hadOneofValue = true
                        if case let .commit(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.payload = .commit(v)
                    }
                }()
            case 44: try {
                    var v: Mentraos_Ble_DisplayDistanceConfig?
                    var hadOneofValue = false
                    if let current = self.payload {
                        hadOneofValue = true
                        if case let .displayDistance(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.payload = .displayDistance(v)
                    }
                }()
            case 45: try {
                    var v: Mentraos_Ble_DisplayHeightConfig?
                    var hadOneofValue = false
                    if let current = self.payload {
                        hadOneofValue = true
                        if case let .displayHeight(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.payload = .displayHeight(v)
                    }
                }()
            case 46: try {
                    var v: Mentraos_Ble_ClearDisplay?
                    var hadOneofValue = false
                    if let current = self.payload {
                        hadOneofValue = true
                        if case let .clearDisplay_p(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.payload = .clearDisplay_p(v)
                    }
                }()
            case 50: try {
                    var v: Mentraos_Ble_ImuEnabledConfig?
                    var hadOneofValue = false
                    if let current = self.payload {
                        hadOneofValue = true
                        if case let .imuEnabled(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.payload = .imuEnabled(v)
                    }
                }()
            case 51: try {
                    var v: Mentraos_Ble_ImuSingleRequest?
                    var hadOneofValue = false
                    if let current = self.payload {
                        hadOneofValue = true
                        if case let .imuSingle(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.payload = .imuSingle(v)
                    }
                }()
            case 52: try {
                    var v: Mentraos_Ble_ImuStreamConfig?
                    var hadOneofValue = false
                    if let current = self.payload {
                        hadOneofValue = true
                        if case let .imuStream(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.payload = .imuStream(v)
                    }
                }()
            case 53: try {
                    var v: Mentraos_Ble_HeadGestureConfig?
                    var hadOneofValue = false
                    if let current = self.payload {
                        hadOneofValue = true
                        if case let .headGesture(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.payload = .headGesture(v)
                    }
                }()
            case 60: try {
                    var v: Mentraos_Ble_RestartRequest?
                    var hadOneofValue = false
                    if let current = self.payload {
                        hadOneofValue = true
                        if case let .restart(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.payload = .restart(v)
                    }
                }()
            case 61: try {
                    var v: Mentraos_Ble_FactoryResetRequest?
                    var hadOneofValue = false
                    if let current = self.payload {
                        hadOneofValue = true
                        if case let .factoryReset(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.payload = .factoryReset(v)
                    }
                }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !msgID.isEmpty {
            try visitor.visitSingularStringField(value: msgID, fieldNumber: 1)
        }
        switch payload {
        case .disconnect?: try {
                guard case let .disconnect(v)? = self.payload else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
            }()
        case .batteryState?: try {
                guard case let .batteryState(v)? = self.payload else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
            }()
        case .glassesInfo?: try {
                guard case let .glassesInfo(v)? = self.payload else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
            }()
        case .pairingMode?: try {
                guard case let .pairingMode(v)? = self.payload else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
            }()
        case .headPosition?: try {
                guard case let .headPosition(v)? = self.payload else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
            }()
        case .headUpAngle?: try {
                guard case let .headUpAngle(v)? = self.payload else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
            }()
        case .pong?: try {
                guard case let .pong(v)? = self.payload else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
            }()
        case .micState?: try {
                guard case let .micState(v)? = self.payload else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
            }()
        case .vadEnabled?: try {
                guard case let .vadEnabled(v)? = self.payload else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
            }()
        case .vadConfig?: try {
                guard case let .vadConfig(v)? = self.payload else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
            }()
        case .displayText?: try {
                guard case let .displayText(v)? = self.payload else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
            }()
        case .displayImage?: try {
                guard case let .displayImage(v)? = self.payload else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
            }()
        case .preloadImage?: try {
                guard case let .preloadImage(v)? = self.payload else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
            }()
        case .displayCachedImage?: try {
                guard case let .displayCachedImage(v)? = self.payload else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
            }()
        case .clearCachedImage_p?: try {
                guard case let .clearCachedImage_p(v)? = self.payload else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 34)
            }()
        case .displayScrollingText?: try {
                guard case let .displayScrollingText(v)? = self.payload else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 35)
            }()
        case .displayPower?: try {
                guard case let .displayPower(v)? = self.payload else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 36)
            }()
        case .brightness?: try {
                guard case let .brightness(v)? = self.payload else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 37)
            }()
        case .autoBrightness?: try {
                guard case let .autoBrightness(v)? = self.payload else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 38)
            }()
        case .autoBrightnessMult?: try {
                guard case let .autoBrightnessMult(v)? = self.payload else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 39)
            }()
        case .drawLine?: try {
                guard case let .drawLine(v)? = self.payload else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 40)
            }()
        case .drawRect?: try {
                guard case let .drawRect(v)? = self.payload else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 41)
            }()
        case .drawCircle?: try {
                guard case let .drawCircle(v)? = self.payload else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 42)
            }()
        case .commit?: try {
                guard case let .commit(v)? = self.payload else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 43)
            }()
        case .displayDistance?: try {
                guard case let .displayDistance(v)? = self.payload else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 44)
            }()
        case .displayHeight?: try {
                guard case let .displayHeight(v)? = self.payload else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 45)
            }()
        case .clearDisplay_p?: try {
                guard case let .clearDisplay_p(v)? = self.payload else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 46)
            }()
        case .imuEnabled?: try {
                guard case let .imuEnabled(v)? = self.payload else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 50)
            }()
        case .imuSingle?: try {
                guard case let .imuSingle(v)? = self.payload else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 51)
            }()
        case .imuStream?: try {
                guard case let .imuStream(v)? = self.payload else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 52)
            }()
        case .headGesture?: try {
                guard case let .headGesture(v)? = self.payload else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 53)
            }()
        case .restart?: try {
                guard case let .restart(v)? = self.payload else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 60)
            }()
        case .factoryReset?: try {
                guard case let .factoryReset(v)? = self.payload else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 61)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Mentraos_Ble_PhoneToGlasses, rhs: Mentraos_Ble_PhoneToGlasses) -> Bool {
        if lhs.msgID != rhs.msgID { return false }
        if lhs.payload != rhs.payload { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Mentraos_Ble_GlassesToPhone: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".GlassesToPhone"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{4}\u{a}battery_status\0\u{3}charging_state\0\u{3}device_info\0\u{3}head_position\0\u{3}head_up_angle_set\0\u{1}ping\0\u{4}\u{5}vad_event\0\u{4}\u{a}image_transfer_complete\0\u{4}\u{a}imu_data\0\u{3}button_event\0\u{3}head_gesture\0")

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 10: try {
                    var v: Mentraos_Ble_BatteryStatus?
                    var hadOneofValue = false
                    if let current = self.payload {
                        hadOneofValue = true
                        if case let .batteryStatus(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.payload = .batteryStatus(v)
                    }
                }()
            case 11: try {
                    var v: Mentraos_Ble_ChargingState?
                    var hadOneofValue = false
                    if let current = self.payload {
                        hadOneofValue = true
                        if case let .chargingState(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.payload = .chargingState(v)
                    }
                }()
            case 12: try {
                    var v: Mentraos_Ble_DeviceInfo?
                    var hadOneofValue = false
                    if let current = self.payload {
                        hadOneofValue = true
                        if case let .deviceInfo(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.payload = .deviceInfo(v)
                    }
                }()
            case 13: try {
                    var v: Mentraos_Ble_HeadPosition?
                    var hadOneofValue = false
                    if let current = self.payload {
                        hadOneofValue = true
                        if case let .headPosition(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.payload = .headPosition(v)
                    }
                }()
            case 14: try {
                    var v: Mentraos_Ble_HeadUpAngleResponse?
                    var hadOneofValue = false
                    if let current = self.payload {
                        hadOneofValue = true
                        if case let .headUpAngleSet(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.payload = .headUpAngleSet(v)
                    }
                }()
            case 15: try {
                    var v: Mentraos_Ble_PingRequest?
                    var hadOneofValue = false
                    if let current = self.payload {
                        hadOneofValue = true
                        if case let .ping(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.payload = .ping(v)
                    }
                }()
            case 20: try {
                    var v: Mentraos_Ble_VadEvent?
                    var hadOneofValue = false
                    if let current = self.payload {
                        hadOneofValue = true
                        if case let .vadEvent(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.payload = .vadEvent(v)
                    }
                }()
            case 30: try {
                    var v: Mentraos_Ble_ImageTransferComplete?
                    var hadOneofValue = false
                    if let current = self.payload {
                        hadOneofValue = true
                        if case let .imageTransferComplete(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.payload = .imageTransferComplete(v)
                    }
                }()
            case 40: try {
                    var v: Mentraos_Ble_ImuData?
                    var hadOneofValue = false
                    if let current = self.payload {
                        hadOneofValue = true
                        if case let .imuData(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.payload = .imuData(v)
                    }
                }()
            case 41: try {
                    var v: Mentraos_Ble_ButtonEvent?
                    var hadOneofValue = false
                    if let current = self.payload {
                        hadOneofValue = true
                        if case let .buttonEvent(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.payload = .buttonEvent(v)
                    }
                }()
            case 42: try {
                    var v: Mentraos_Ble_HeadGesture?
                    var hadOneofValue = false
                    if let current = self.payload {
                        hadOneofValue = true
                        if case let .headGesture(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.payload = .headGesture(v)
                    }
                }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        switch payload {
        case .batteryStatus?: try {
                guard case let .batteryStatus(v)? = self.payload else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
            }()
        case .chargingState?: try {
                guard case let .chargingState(v)? = self.payload else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
            }()
        case .deviceInfo?: try {
                guard case let .deviceInfo(v)? = self.payload else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
            }()
        case .headPosition?: try {
                guard case let .headPosition(v)? = self.payload else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
            }()
        case .headUpAngleSet?: try {
                guard case let .headUpAngleSet(v)? = self.payload else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
            }()
        case .ping?: try {
                guard case let .ping(v)? = self.payload else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
            }()
        case .vadEvent?: try {
                guard case let .vadEvent(v)? = self.payload else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
            }()
        case .imageTransferComplete?: try {
                guard case let .imageTransferComplete(v)? = self.payload else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
            }()
        case .imuData?: try {
                guard case let .imuData(v)? = self.payload else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 40)
            }()
        case .buttonEvent?: try {
                guard case let .buttonEvent(v)? = self.payload else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 41)
            }()
        case .headGesture?: try {
                guard case let .headGesture(v)? = self.payload else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 42)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Mentraos_Ble_GlassesToPhone, rhs: Mentraos_Ble_GlassesToPhone) -> Bool {
        if lhs.payload != rhs.payload { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Mentraos_Ble_DisconnectRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".DisconnectRequest"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        // Load everything into unknown fields
        while try decoder.nextFieldNumber() != nil {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Mentraos_Ble_DisconnectRequest, rhs: Mentraos_Ble_DisconnectRequest) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Mentraos_Ble_BatteryStateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".BatteryStateRequest"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        // Load everything into unknown fields
        while try decoder.nextFieldNumber() != nil {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Mentraos_Ble_BatteryStateRequest, rhs: Mentraos_Ble_BatteryStateRequest) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Mentraos_Ble_BatteryStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".BatteryStatus"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}level\0\u{1}charging\0")

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularUInt32Field(value: &level)
            case 2: try decoder.decodeSingularBoolField(value: &charging)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if level != 0 {
            try visitor.visitSingularUInt32Field(value: level, fieldNumber: 1)
        }
        if charging != false {
            try visitor.visitSingularBoolField(value: charging, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Mentraos_Ble_BatteryStatus, rhs: Mentraos_Ble_BatteryStatus) -> Bool {
        if lhs.level != rhs.level { return false }
        if lhs.charging != rhs.charging { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Mentraos_Ble_ChargingState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ChargingState"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}state\0")

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularEnumField(value: &state)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if state != .notCharging {
            try visitor.visitSingularEnumField(value: state, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Mentraos_Ble_ChargingState, rhs: Mentraos_Ble_ChargingState) -> Bool {
        if lhs.state != rhs.state { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Mentraos_Ble_ChargingState.State: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0NOT_CHARGING\0\u{1}CHARGING\0")
}

extension Mentraos_Ble_GlassesInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".GlassesInfoRequest"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        // Load everything into unknown fields
        while try decoder.nextFieldNumber() != nil {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Mentraos_Ble_GlassesInfoRequest, rhs: Mentraos_Ble_GlassesInfoRequest) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Mentraos_Ble_DeviceInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".DeviceInfo"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}fw_version\0\u{3}hw_model\0\u{1}features\0")

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &fwVersion)
            case 2: try decoder.decodeSingularStringField(value: &hwModel)
            case 3: try decoder.decodeSingularMessageField(value: &_features)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !fwVersion.isEmpty {
            try visitor.visitSingularStringField(value: fwVersion, fieldNumber: 1)
        }
        if !hwModel.isEmpty {
            try visitor.visitSingularStringField(value: hwModel, fieldNumber: 2)
        }
        try { if let v = self._features {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Mentraos_Ble_DeviceInfo, rhs: Mentraos_Ble_DeviceInfo) -> Bool {
        if lhs.fwVersion != rhs.fwVersion { return false }
        if lhs.hwModel != rhs.hwModel { return false }
        if lhs._features != rhs._features { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Mentraos_Ble_DeviceFeatures: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".DeviceFeatures"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}camera\0\u{1}display\0\u{3}audio_tx\0\u{3}audio_rx\0\u{1}imu\0\u{1}vad\0\u{3}mic_switching\0\u{3}image_chunk_buffer\0")

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBoolField(value: &camera)
            case 2: try decoder.decodeSingularBoolField(value: &display)
            case 3: try decoder.decodeSingularBoolField(value: &audioTx)
            case 4: try decoder.decodeSingularBoolField(value: &audioRx)
            case 5: try decoder.decodeSingularBoolField(value: &imu)
            case 6: try decoder.decodeSingularBoolField(value: &vad)
            case 7: try decoder.decodeSingularBoolField(value: &micSwitching)
            case 8: try decoder.decodeSingularUInt32Field(value: &imageChunkBuffer)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if camera != false {
            try visitor.visitSingularBoolField(value: camera, fieldNumber: 1)
        }
        if display != false {
            try visitor.visitSingularBoolField(value: display, fieldNumber: 2)
        }
        if audioTx != false {
            try visitor.visitSingularBoolField(value: audioTx, fieldNumber: 3)
        }
        if audioRx != false {
            try visitor.visitSingularBoolField(value: audioRx, fieldNumber: 4)
        }
        if imu != false {
            try visitor.visitSingularBoolField(value: imu, fieldNumber: 5)
        }
        if vad != false {
            try visitor.visitSingularBoolField(value: vad, fieldNumber: 6)
        }
        if micSwitching != false {
            try visitor.visitSingularBoolField(value: micSwitching, fieldNumber: 7)
        }
        if imageChunkBuffer != 0 {
            try visitor.visitSingularUInt32Field(value: imageChunkBuffer, fieldNumber: 8)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Mentraos_Ble_DeviceFeatures, rhs: Mentraos_Ble_DeviceFeatures) -> Bool {
        if lhs.camera != rhs.camera { return false }
        if lhs.display != rhs.display { return false }
        if lhs.audioTx != rhs.audioTx { return false }
        if lhs.audioRx != rhs.audioRx { return false }
        if lhs.imu != rhs.imu { return false }
        if lhs.vad != rhs.vad { return false }
        if lhs.micSwitching != rhs.micSwitching { return false }
        if lhs.imageChunkBuffer != rhs.imageChunkBuffer { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Mentraos_Ble_PairingModeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".PairingModeRequest"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        // Load everything into unknown fields
        while try decoder.nextFieldNumber() != nil {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Mentraos_Ble_PairingModeRequest, rhs: Mentraos_Ble_PairingModeRequest) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Mentraos_Ble_HeadPositionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".HeadPositionRequest"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        // Load everything into unknown fields
        while try decoder.nextFieldNumber() != nil {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Mentraos_Ble_HeadPositionRequest, rhs: Mentraos_Ble_HeadPositionRequest) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Mentraos_Ble_HeadPosition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".HeadPosition"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}angle\0")

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularInt32Field(value: &angle)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if angle != 0 {
            try visitor.visitSingularInt32Field(value: angle, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Mentraos_Ble_HeadPosition, rhs: Mentraos_Ble_HeadPosition) -> Bool {
        if lhs.angle != rhs.angle { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Mentraos_Ble_HeadUpAngleConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".HeadUpAngleConfig"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}angle\0")

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularUInt32Field(value: &angle)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if angle != 0 {
            try visitor.visitSingularUInt32Field(value: angle, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Mentraos_Ble_HeadUpAngleConfig, rhs: Mentraos_Ble_HeadUpAngleConfig) -> Bool {
        if lhs.angle != rhs.angle { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Mentraos_Ble_HeadUpAngleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".HeadUpAngleResponse"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0")

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBoolField(value: &success)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if success != false {
            try visitor.visitSingularBoolField(value: success, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Mentraos_Ble_HeadUpAngleResponse, rhs: Mentraos_Ble_HeadUpAngleResponse) -> Bool {
        if lhs.success != rhs.success { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Mentraos_Ble_PingRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".PingRequest"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        // Load everything into unknown fields
        while try decoder.nextFieldNumber() != nil {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Mentraos_Ble_PingRequest, rhs: Mentraos_Ble_PingRequest) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Mentraos_Ble_PongResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".PongResponse"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        // Load everything into unknown fields
        while try decoder.nextFieldNumber() != nil {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Mentraos_Ble_PongResponse, rhs: Mentraos_Ble_PongResponse) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Mentraos_Ble_MicStateConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".MicStateConfig"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}enabled\0")

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBoolField(value: &enabled)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if enabled != false {
            try visitor.visitSingularBoolField(value: enabled, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Mentraos_Ble_MicStateConfig, rhs: Mentraos_Ble_MicStateConfig) -> Bool {
        if lhs.enabled != rhs.enabled { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Mentraos_Ble_VadEnabledConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".VadEnabledConfig"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}enabled\0")

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBoolField(value: &enabled)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if enabled != false {
            try visitor.visitSingularBoolField(value: enabled, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Mentraos_Ble_VadEnabledConfig, rhs: Mentraos_Ble_VadEnabledConfig) -> Bool {
        if lhs.enabled != rhs.enabled { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Mentraos_Ble_VadConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".VadConfig"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}sensitivity\0")

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularUInt32Field(value: &sensitivity)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if sensitivity != 0 {
            try visitor.visitSingularUInt32Field(value: sensitivity, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Mentraos_Ble_VadConfig, rhs: Mentraos_Ble_VadConfig) -> Bool {
        if lhs.sensitivity != rhs.sensitivity { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Mentraos_Ble_VadEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".VadEvent"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}state\0")

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularEnumField(value: &state)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if state != .inactive {
            try visitor.visitSingularEnumField(value: state, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Mentraos_Ble_VadEvent, rhs: Mentraos_Ble_VadEvent) -> Bool {
        if lhs.state != rhs.state { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Mentraos_Ble_VadEvent.State: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0INACTIVE\0\u{1}ACTIVE\0")
}

extension Mentraos_Ble_DisplayText: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".DisplayText"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}text\0\u{1}color\0\u{3}font_code\0\u{1}x\0\u{1}y\0\u{1}size\0")

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &text)
            case 2: try decoder.decodeSingularUInt32Field(value: &color)
            case 3: try decoder.decodeSingularUInt32Field(value: &fontCode)
            case 4: try decoder.decodeSingularUInt32Field(value: &x)
            case 5: try decoder.decodeSingularUInt32Field(value: &y)
            case 6: try decoder.decodeSingularUInt32Field(value: &size)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !text.isEmpty {
            try visitor.visitSingularStringField(value: text, fieldNumber: 1)
        }
        if color != 0 {
            try visitor.visitSingularUInt32Field(value: color, fieldNumber: 2)
        }
        if fontCode != 0 {
            try visitor.visitSingularUInt32Field(value: fontCode, fieldNumber: 3)
        }
        if x != 0 {
            try visitor.visitSingularUInt32Field(value: x, fieldNumber: 4)
        }
        if y != 0 {
            try visitor.visitSingularUInt32Field(value: y, fieldNumber: 5)
        }
        if size != 0 {
            try visitor.visitSingularUInt32Field(value: size, fieldNumber: 6)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Mentraos_Ble_DisplayText, rhs: Mentraos_Ble_DisplayText) -> Bool {
        if lhs.text != rhs.text { return false }
        if lhs.color != rhs.color { return false }
        if lhs.fontCode != rhs.fontCode { return false }
        if lhs.x != rhs.x { return false }
        if lhs.y != rhs.y { return false }
        if lhs.size != rhs.size { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Mentraos_Ble_DisplayImage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".DisplayImage"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}stream_id\0\u{1}x\0\u{1}y\0\u{1}width\0\u{1}height\0\u{1}encoding\0\u{3}total_chunks\0")

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &streamID)
            case 2: try decoder.decodeSingularUInt32Field(value: &x)
            case 3: try decoder.decodeSingularUInt32Field(value: &y)
            case 4: try decoder.decodeSingularUInt32Field(value: &width)
            case 5: try decoder.decodeSingularUInt32Field(value: &height)
            case 6: try decoder.decodeSingularStringField(value: &encoding)
            case 7: try decoder.decodeSingularUInt32Field(value: &totalChunks)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !streamID.isEmpty {
            try visitor.visitSingularStringField(value: streamID, fieldNumber: 1)
        }
        if x != 0 {
            try visitor.visitSingularUInt32Field(value: x, fieldNumber: 2)
        }
        if y != 0 {
            try visitor.visitSingularUInt32Field(value: y, fieldNumber: 3)
        }
        if width != 0 {
            try visitor.visitSingularUInt32Field(value: width, fieldNumber: 4)
        }
        if height != 0 {
            try visitor.visitSingularUInt32Field(value: height, fieldNumber: 5)
        }
        if !encoding.isEmpty {
            try visitor.visitSingularStringField(value: encoding, fieldNumber: 6)
        }
        if totalChunks != 0 {
            try visitor.visitSingularUInt32Field(value: totalChunks, fieldNumber: 7)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Mentraos_Ble_DisplayImage, rhs: Mentraos_Ble_DisplayImage) -> Bool {
        if lhs.streamID != rhs.streamID { return false }
        if lhs.x != rhs.x { return false }
        if lhs.y != rhs.y { return false }
        if lhs.width != rhs.width { return false }
        if lhs.height != rhs.height { return false }
        if lhs.encoding != rhs.encoding { return false }
        if lhs.totalChunks != rhs.totalChunks { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Mentraos_Ble_PreloadImage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".PreloadImage"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}stream_id\0\u{3}image_id\0\u{1}width\0\u{1}height\0\u{1}encoding\0\u{3}total_chunks\0")

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &streamID)
            case 2: try decoder.decodeSingularUInt32Field(value: &imageID)
            case 3: try decoder.decodeSingularUInt32Field(value: &width)
            case 4: try decoder.decodeSingularUInt32Field(value: &height)
            case 5: try decoder.decodeSingularStringField(value: &encoding)
            case 6: try decoder.decodeSingularUInt32Field(value: &totalChunks)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !streamID.isEmpty {
            try visitor.visitSingularStringField(value: streamID, fieldNumber: 1)
        }
        if imageID != 0 {
            try visitor.visitSingularUInt32Field(value: imageID, fieldNumber: 2)
        }
        if width != 0 {
            try visitor.visitSingularUInt32Field(value: width, fieldNumber: 3)
        }
        if height != 0 {
            try visitor.visitSingularUInt32Field(value: height, fieldNumber: 4)
        }
        if !encoding.isEmpty {
            try visitor.visitSingularStringField(value: encoding, fieldNumber: 5)
        }
        if totalChunks != 0 {
            try visitor.visitSingularUInt32Field(value: totalChunks, fieldNumber: 6)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Mentraos_Ble_PreloadImage, rhs: Mentraos_Ble_PreloadImage) -> Bool {
        if lhs.streamID != rhs.streamID { return false }
        if lhs.imageID != rhs.imageID { return false }
        if lhs.width != rhs.width { return false }
        if lhs.height != rhs.height { return false }
        if lhs.encoding != rhs.encoding { return false }
        if lhs.totalChunks != rhs.totalChunks { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Mentraos_Ble_DisplayCachedImage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".DisplayCachedImage"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}image_id\0\u{1}x\0\u{1}y\0\u{1}width\0\u{1}height\0")

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularUInt32Field(value: &imageID)
            case 2: try decoder.decodeSingularUInt32Field(value: &x)
            case 3: try decoder.decodeSingularUInt32Field(value: &y)
            case 4: try decoder.decodeSingularUInt32Field(value: &width)
            case 5: try decoder.decodeSingularUInt32Field(value: &height)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if imageID != 0 {
            try visitor.visitSingularUInt32Field(value: imageID, fieldNumber: 1)
        }
        if x != 0 {
            try visitor.visitSingularUInt32Field(value: x, fieldNumber: 2)
        }
        if y != 0 {
            try visitor.visitSingularUInt32Field(value: y, fieldNumber: 3)
        }
        if width != 0 {
            try visitor.visitSingularUInt32Field(value: width, fieldNumber: 4)
        }
        if height != 0 {
            try visitor.visitSingularUInt32Field(value: height, fieldNumber: 5)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Mentraos_Ble_DisplayCachedImage, rhs: Mentraos_Ble_DisplayCachedImage) -> Bool {
        if lhs.imageID != rhs.imageID { return false }
        if lhs.x != rhs.x { return false }
        if lhs.y != rhs.y { return false }
        if lhs.width != rhs.width { return false }
        if lhs.height != rhs.height { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Mentraos_Ble_ClearCachedImage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ClearCachedImage"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}image_id\0")

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularUInt32Field(value: &imageID)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if imageID != 0 {
            try visitor.visitSingularUInt32Field(value: imageID, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Mentraos_Ble_ClearCachedImage, rhs: Mentraos_Ble_ClearCachedImage) -> Bool {
        if lhs.imageID != rhs.imageID { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Mentraos_Ble_DisplayScrollingText: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".DisplayScrollingText"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}text\0\u{1}color\0\u{3}font_code\0\u{1}x\0\u{1}y\0\u{1}width\0\u{1}height\0\u{1}align\0\u{3}line_spacing\0\u{1}speed\0\u{1}size\0\u{1}loop\0\u{3}pause_ms\0")

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &text)
            case 2: try decoder.decodeSingularUInt32Field(value: &color)
            case 3: try decoder.decodeSingularUInt32Field(value: &fontCode)
            case 4: try decoder.decodeSingularUInt32Field(value: &x)
            case 5: try decoder.decodeSingularUInt32Field(value: &y)
            case 6: try decoder.decodeSingularUInt32Field(value: &width)
            case 7: try decoder.decodeSingularUInt32Field(value: &height)
            case 8: try decoder.decodeSingularEnumField(value: &align)
            case 9: try decoder.decodeSingularUInt32Field(value: &lineSpacing)
            case 10: try decoder.decodeSingularUInt32Field(value: &speed)
            case 11: try decoder.decodeSingularUInt32Field(value: &size)
            case 12: try decoder.decodeSingularBoolField(value: &loop)
            case 13: try decoder.decodeSingularUInt32Field(value: &pauseMs)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !text.isEmpty {
            try visitor.visitSingularStringField(value: text, fieldNumber: 1)
        }
        if color != 0 {
            try visitor.visitSingularUInt32Field(value: color, fieldNumber: 2)
        }
        if fontCode != 0 {
            try visitor.visitSingularUInt32Field(value: fontCode, fieldNumber: 3)
        }
        if x != 0 {
            try visitor.visitSingularUInt32Field(value: x, fieldNumber: 4)
        }
        if y != 0 {
            try visitor.visitSingularUInt32Field(value: y, fieldNumber: 5)
        }
        if width != 0 {
            try visitor.visitSingularUInt32Field(value: width, fieldNumber: 6)
        }
        if height != 0 {
            try visitor.visitSingularUInt32Field(value: height, fieldNumber: 7)
        }
        if align != .left {
            try visitor.visitSingularEnumField(value: align, fieldNumber: 8)
        }
        if lineSpacing != 0 {
            try visitor.visitSingularUInt32Field(value: lineSpacing, fieldNumber: 9)
        }
        if speed != 0 {
            try visitor.visitSingularUInt32Field(value: speed, fieldNumber: 10)
        }
        if size != 0 {
            try visitor.visitSingularUInt32Field(value: size, fieldNumber: 11)
        }
        if loop != false {
            try visitor.visitSingularBoolField(value: loop, fieldNumber: 12)
        }
        if pauseMs != 0 {
            try visitor.visitSingularUInt32Field(value: pauseMs, fieldNumber: 13)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Mentraos_Ble_DisplayScrollingText, rhs: Mentraos_Ble_DisplayScrollingText) -> Bool {
        if lhs.text != rhs.text { return false }
        if lhs.color != rhs.color { return false }
        if lhs.fontCode != rhs.fontCode { return false }
        if lhs.x != rhs.x { return false }
        if lhs.y != rhs.y { return false }
        if lhs.width != rhs.width { return false }
        if lhs.height != rhs.height { return false }
        if lhs.align != rhs.align { return false }
        if lhs.lineSpacing != rhs.lineSpacing { return false }
        if lhs.speed != rhs.speed { return false }
        if lhs.size != rhs.size { return false }
        if lhs.loop != rhs.loop { return false }
        if lhs.pauseMs != rhs.pauseMs { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Mentraos_Ble_DisplayScrollingText.Alignment: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0LEFT\0\u{1}CENTER\0\u{1}RIGHT\0")
}

extension Mentraos_Ble_DisplayPowerConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".DisplayPowerConfig"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}on\0")

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBoolField(value: &on)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if on != false {
            try visitor.visitSingularBoolField(value: on, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Mentraos_Ble_DisplayPowerConfig, rhs: Mentraos_Ble_DisplayPowerConfig) -> Bool {
        if lhs.on != rhs.on { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Mentraos_Ble_BrightnessConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".BrightnessConfig"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}value\0")

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularUInt32Field(value: &value)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if value != 0 {
            try visitor.visitSingularUInt32Field(value: value, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Mentraos_Ble_BrightnessConfig, rhs: Mentraos_Ble_BrightnessConfig) -> Bool {
        if lhs.value != rhs.value { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Mentraos_Ble_AutoBrightnessConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".AutoBrightnessConfig"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}enabled\0")

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBoolField(value: &enabled)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if enabled != false {
            try visitor.visitSingularBoolField(value: enabled, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Mentraos_Ble_AutoBrightnessConfig, rhs: Mentraos_Ble_AutoBrightnessConfig) -> Bool {
        if lhs.enabled != rhs.enabled { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Mentraos_Ble_AutoBrightnessMultiplier: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".AutoBrightnessMultiplier"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}multiplier\0")

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularFloatField(value: &multiplier)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if multiplier.bitPattern != 0 {
            try visitor.visitSingularFloatField(value: multiplier, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Mentraos_Ble_AutoBrightnessMultiplier, rhs: Mentraos_Ble_AutoBrightnessMultiplier) -> Bool {
        if lhs.multiplier != rhs.multiplier { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Mentraos_Ble_DrawLine: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".DrawLine"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}color\0\u{1}stroke\0\u{1}x1\0\u{1}y1\0\u{1}x2\0\u{1}y2\0")

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularUInt32Field(value: &color)
            case 2: try decoder.decodeSingularUInt32Field(value: &stroke)
            case 3: try decoder.decodeSingularUInt32Field(value: &x1)
            case 4: try decoder.decodeSingularUInt32Field(value: &y1)
            case 5: try decoder.decodeSingularUInt32Field(value: &x2)
            case 6: try decoder.decodeSingularUInt32Field(value: &y2)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if color != 0 {
            try visitor.visitSingularUInt32Field(value: color, fieldNumber: 1)
        }
        if stroke != 0 {
            try visitor.visitSingularUInt32Field(value: stroke, fieldNumber: 2)
        }
        if x1 != 0 {
            try visitor.visitSingularUInt32Field(value: x1, fieldNumber: 3)
        }
        if y1 != 0 {
            try visitor.visitSingularUInt32Field(value: y1, fieldNumber: 4)
        }
        if x2 != 0 {
            try visitor.visitSingularUInt32Field(value: x2, fieldNumber: 5)
        }
        if y2 != 0 {
            try visitor.visitSingularUInt32Field(value: y2, fieldNumber: 6)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Mentraos_Ble_DrawLine, rhs: Mentraos_Ble_DrawLine) -> Bool {
        if lhs.color != rhs.color { return false }
        if lhs.stroke != rhs.stroke { return false }
        if lhs.x1 != rhs.x1 { return false }
        if lhs.y1 != rhs.y1 { return false }
        if lhs.x2 != rhs.x2 { return false }
        if lhs.y2 != rhs.y2 { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Mentraos_Ble_DrawRect: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".DrawRect"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}color\0\u{1}stroke\0\u{1}x\0\u{1}y\0\u{1}width\0\u{1}height\0")

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularUInt32Field(value: &color)
            case 2: try decoder.decodeSingularUInt32Field(value: &stroke)
            case 3: try decoder.decodeSingularUInt32Field(value: &x)
            case 4: try decoder.decodeSingularUInt32Field(value: &y)
            case 5: try decoder.decodeSingularUInt32Field(value: &width)
            case 6: try decoder.decodeSingularUInt32Field(value: &height)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if color != 0 {
            try visitor.visitSingularUInt32Field(value: color, fieldNumber: 1)
        }
        if stroke != 0 {
            try visitor.visitSingularUInt32Field(value: stroke, fieldNumber: 2)
        }
        if x != 0 {
            try visitor.visitSingularUInt32Field(value: x, fieldNumber: 3)
        }
        if y != 0 {
            try visitor.visitSingularUInt32Field(value: y, fieldNumber: 4)
        }
        if width != 0 {
            try visitor.visitSingularUInt32Field(value: width, fieldNumber: 5)
        }
        if height != 0 {
            try visitor.visitSingularUInt32Field(value: height, fieldNumber: 6)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Mentraos_Ble_DrawRect, rhs: Mentraos_Ble_DrawRect) -> Bool {
        if lhs.color != rhs.color { return false }
        if lhs.stroke != rhs.stroke { return false }
        if lhs.x != rhs.x { return false }
        if lhs.y != rhs.y { return false }
        if lhs.width != rhs.width { return false }
        if lhs.height != rhs.height { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Mentraos_Ble_DrawCircle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".DrawCircle"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}color\0\u{1}stroke\0\u{1}x\0\u{1}y\0\u{1}radius\0")

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularUInt32Field(value: &color)
            case 2: try decoder.decodeSingularUInt32Field(value: &stroke)
            case 3: try decoder.decodeSingularUInt32Field(value: &x)
            case 4: try decoder.decodeSingularUInt32Field(value: &y)
            case 5: try decoder.decodeSingularUInt32Field(value: &radius)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if color != 0 {
            try visitor.visitSingularUInt32Field(value: color, fieldNumber: 1)
        }
        if stroke != 0 {
            try visitor.visitSingularUInt32Field(value: stroke, fieldNumber: 2)
        }
        if x != 0 {
            try visitor.visitSingularUInt32Field(value: x, fieldNumber: 3)
        }
        if y != 0 {
            try visitor.visitSingularUInt32Field(value: y, fieldNumber: 4)
        }
        if radius != 0 {
            try visitor.visitSingularUInt32Field(value: radius, fieldNumber: 5)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Mentraos_Ble_DrawCircle, rhs: Mentraos_Ble_DrawCircle) -> Bool {
        if lhs.color != rhs.color { return false }
        if lhs.stroke != rhs.stroke { return false }
        if lhs.x != rhs.x { return false }
        if lhs.y != rhs.y { return false }
        if lhs.radius != rhs.radius { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Mentraos_Ble_CommitDisplay: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".CommitDisplay"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        // Load everything into unknown fields
        while try decoder.nextFieldNumber() != nil {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Mentraos_Ble_CommitDisplay, rhs: Mentraos_Ble_CommitDisplay) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Mentraos_Ble_ClearDisplay: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ClearDisplay"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        // Load everything into unknown fields
        while try decoder.nextFieldNumber() != nil {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Mentraos_Ble_ClearDisplay, rhs: Mentraos_Ble_ClearDisplay) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Mentraos_Ble_DisplayDistanceConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".DisplayDistanceConfig"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}distance_cm\0")

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularUInt32Field(value: &distanceCm)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if distanceCm != 0 {
            try visitor.visitSingularUInt32Field(value: distanceCm, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Mentraos_Ble_DisplayDistanceConfig, rhs: Mentraos_Ble_DisplayDistanceConfig) -> Bool {
        if lhs.distanceCm != rhs.distanceCm { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Mentraos_Ble_DisplayHeightConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".DisplayHeightConfig"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}height\0")

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularUInt32Field(value: &height)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if height != 0 {
            try visitor.visitSingularUInt32Field(value: height, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Mentraos_Ble_DisplayHeightConfig, rhs: Mentraos_Ble_DisplayHeightConfig) -> Bool {
        if lhs.height != rhs.height { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Mentraos_Ble_ImageTransferComplete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ImageTransferComplete"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}stream_id\0\u{1}status\0\u{3}missing_chunks\0")

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &streamID)
            case 2: try decoder.decodeSingularEnumField(value: &status)
            case 3: try decoder.decodeRepeatedUInt32Field(value: &missingChunks)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !streamID.isEmpty {
            try visitor.visitSingularStringField(value: streamID, fieldNumber: 1)
        }
        if status != .ok {
            try visitor.visitSingularEnumField(value: status, fieldNumber: 2)
        }
        if !missingChunks.isEmpty {
            try visitor.visitPackedUInt32Field(value: missingChunks, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Mentraos_Ble_ImageTransferComplete, rhs: Mentraos_Ble_ImageTransferComplete) -> Bool {
        if lhs.streamID != rhs.streamID { return false }
        if lhs.status != rhs.status { return false }
        if lhs.missingChunks != rhs.missingChunks { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Mentraos_Ble_ImageTransferComplete.Status: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0OK\0\u{1}INCOMPLETE\0")
}

extension Mentraos_Ble_ImuEnabledConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ImuEnabledConfig"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}enabled\0")

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBoolField(value: &enabled)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if enabled != false {
            try visitor.visitSingularBoolField(value: enabled, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Mentraos_Ble_ImuEnabledConfig, rhs: Mentraos_Ble_ImuEnabledConfig) -> Bool {
        if lhs.enabled != rhs.enabled { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Mentraos_Ble_ImuSingleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ImuSingleRequest"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        // Load everything into unknown fields
        while try decoder.nextFieldNumber() != nil {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Mentraos_Ble_ImuSingleRequest, rhs: Mentraos_Ble_ImuSingleRequest) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Mentraos_Ble_ImuStreamConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ImuStreamConfig"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}enabled\0")

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBoolField(value: &enabled)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if enabled != false {
            try visitor.visitSingularBoolField(value: enabled, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Mentraos_Ble_ImuStreamConfig, rhs: Mentraos_Ble_ImuStreamConfig) -> Bool {
        if lhs.enabled != rhs.enabled { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Mentraos_Ble_ImuData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ImuData"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}accel\0\u{1}gyro\0\u{1}mag\0")

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_accel)
            case 2: try decoder.decodeSingularMessageField(value: &_gyro)
            case 3: try decoder.decodeSingularMessageField(value: &_mag)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._accel {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try { if let v = self._gyro {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try { if let v = self._mag {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Mentraos_Ble_ImuData, rhs: Mentraos_Ble_ImuData) -> Bool {
        if lhs._accel != rhs._accel { return false }
        if lhs._gyro != rhs._gyro { return false }
        if lhs._mag != rhs._mag { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Mentraos_Ble_Vector3: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".Vector3"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}x\0\u{1}y\0\u{1}z\0")

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularFloatField(value: &x)
            case 2: try decoder.decodeSingularFloatField(value: &y)
            case 3: try decoder.decodeSingularFloatField(value: &z)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if x.bitPattern != 0 {
            try visitor.visitSingularFloatField(value: x, fieldNumber: 1)
        }
        if y.bitPattern != 0 {
            try visitor.visitSingularFloatField(value: y, fieldNumber: 2)
        }
        if z.bitPattern != 0 {
            try visitor.visitSingularFloatField(value: z, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Mentraos_Ble_Vector3, rhs: Mentraos_Ble_Vector3) -> Bool {
        if lhs.x != rhs.x { return false }
        if lhs.y != rhs.y { return false }
        if lhs.z != rhs.z { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Mentraos_Ble_ButtonEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ButtonEvent"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}button\0\u{1}state\0")

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularEnumField(value: &button)
            case 2: try decoder.decodeSingularEnumField(value: &state)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if button != .center {
            try visitor.visitSingularEnumField(value: button, fieldNumber: 1)
        }
        if state != .up {
            try visitor.visitSingularEnumField(value: state, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Mentraos_Ble_ButtonEvent, rhs: Mentraos_Ble_ButtonEvent) -> Bool {
        if lhs.button != rhs.button { return false }
        if lhs.state != rhs.state { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Mentraos_Ble_ButtonEvent.Button: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0CENTER\0\u{1}LEFT\0\u{1}RIGHT\0")
}

extension Mentraos_Ble_ButtonEvent.State: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0UP\0\u{1}DOWN\0")
}

extension Mentraos_Ble_HeadGesture: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".HeadGesture"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}gesture\0")

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularEnumField(value: &gesture)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if gesture != .nod {
            try visitor.visitSingularEnumField(value: gesture, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Mentraos_Ble_HeadGesture, rhs: Mentraos_Ble_HeadGesture) -> Bool {
        if lhs.gesture != rhs.gesture { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Mentraos_Ble_HeadGesture.Gesture: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0NOD\0\u{1}SHAKE\0\u{1}HEAD_UP\0")
}

extension Mentraos_Ble_HeadGestureConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".HeadGestureConfig"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}gesture\0\u{1}enabled\0")

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularEnumField(value: &gesture)
            case 2: try decoder.decodeSingularBoolField(value: &enabled)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if gesture != .nod {
            try visitor.visitSingularEnumField(value: gesture, fieldNumber: 1)
        }
        if enabled != false {
            try visitor.visitSingularBoolField(value: enabled, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Mentraos_Ble_HeadGestureConfig, rhs: Mentraos_Ble_HeadGestureConfig) -> Bool {
        if lhs.gesture != rhs.gesture { return false }
        if lhs.enabled != rhs.enabled { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Mentraos_Ble_RestartRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".RestartRequest"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        // Load everything into unknown fields
        while try decoder.nextFieldNumber() != nil {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Mentraos_Ble_RestartRequest, rhs: Mentraos_Ble_RestartRequest) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Mentraos_Ble_FactoryResetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".FactoryResetRequest"
    static let _protobuf_nameMap = SwiftProtobuf._NameMap()

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        // Load everything into unknown fields
        while try decoder.nextFieldNumber() != nil {}
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Mentraos_Ble_FactoryResetRequest, rhs: Mentraos_Ble_FactoryResetRequest) -> Bool {
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}
